; le main file for this
; 
;        /"""/  /"""//"""""""""//"""/      /"""/
;       /   /  /   //   ______//   /      /   /
;      /   /  /   //   /      /   /      /   /
;     /    """   //    """""//   /      /   /
;    /   ___    //   ______//   /      /   /
;   /   /  /   //   /      /   /      /   /
;  /   /  /   //    """""//    """""//    """""/
; /___/  /___//_________//_________//_________/
; honestly i just dont know how to name this

include "hardware.inc"
include "macros.inc"
include "defines.inc"

section "crash", rom0[$38]
zCrash:
	ld b, b
	jr @

section "header", rom0[$100]
	di
	jp ConsoleCheck
	ds $150-@, $00

section "title", rom0
Title::
	jp Main
.loop

section "main", rom0
Main::
	; set player position
	ld a, bank(wxActor)
	ldh [rSMBK], a
	ld a, START_Y
	ld [wxActor.y], a
	if START_X != START_Y
		ld a, START_X
	endc
	ld [wxActor.x], a
	; load tileset
	ld a, bank(Tileset2bpp)
	ld [rROMB], a
	ld hl, Tileset2bpp
	ld de, _VRAM+$1000
	ld bc, Tileset2bpp.end - Tileset2bpp
	call SafeCpy
	; load the map
	call LoadMap
.loop
	call Joy
	call MovePlayer
	jr .loop

section "player", rom0
MovePlayer:
	; check if player wants to move
	ld a, [hPad1]
	ld b, a
	ldh a, [hPad1.diff]
	and b
	and $f0
	ret z
	; if so, move
	ld b, a
	ld c, 0
	; vertically
		ld a, [wxActor.y]
		ld d, a
		; down
		sla b
		adc c
		; up
		sla b
		sbc c
		call CollideMap
		ld [wxActor.y], a
		xor d
		and $f0
		call nz, LoadMap
	; horizontally
		ld a, [wxActor.x]
		ld d, a
		; left
		sla b
		sbc c
		; right
		sla b
		adc c
		ld [wxActor.x], a
		xor d
		and $f0
		call nz, LoadMap
	ret

section "fetchmaptile", rom0 ; name possibly misleading?
FetchMapTile:: ; h - Y, l - X, rROMB = bank, hl = tile, clobbers de
	; since hl is practically already pointing to the
	; tile we only need to actually fetch the bank
	; fetch and switch to bank
	ld a, h
	rlca
	rlca
	or %11111100
		assert low(MapLut) == %11111100
	ld e, a
	ld d, HIGH(MapLut)
	ld a, [de]
	ld [rROMB], a
	; adjust h
	res 7, h
	set 6, h
		assert high(Map1)  == (%0<<7) | (%1<<6)
	ret

section "loadmap", rom0
LoadMap::
	ld a, bank(wxActor)
	ldh [rSMBK], a
	; fetch the screen bank
	ld a, [wxActor.y]
	and $f0
	ldh [hCamera.y], a
	ld h, a
	ld a, [wxActor.x]
	and $f0
	ldh [hCamera.x], a
	ld l, a
	call FetchMapTile
	; load c and de
	ld c, 16 ; couldnt come up with a constant for this
	ld de, _SCRN0
	.column ; copy a column of rows
		ld b, b
		ld b, 16/2 ; or this
		push hl
	.row ; copy a row
		.wait ; wait for safe access
		ldh a, [rSTAT]
		and STATF_BUSY
		jr nz, .wait
		rept 2 ; copy two bytes
			ld a, [hl+]
			ld [de], a
			inc e
			endr
		dec b
		jr nz, .row
	; adjust for the next row
		; hl
		pop hl
		inc h
		; de
		ld a, e
		add 15
		ld e, a
		inc de
		; then decrement counter
		dec c
		jr nz, .column
	; done
	ret

section "hram", hram
hCamera::
	.y ds 1 ; y position of camera
	.x ds 1 ; x position of camera

section "collidemap", rom0
CollideMap::
	; done
	ret

section "actors", wramx, align[8]
wxActor::
	.type ds 1
	.y    ds 1
	.x    ds 1
.next ds 256*(MAX_ACTORS-1)

section "tileset", romx
Tileset2bpp:
	incbin "tileset.2bpp"
	.end

for V, 4
section "map{x:V}", romx
Map{x:V}::
	incbin "map.bin", V*(2**14), 2**14
endr

section "maplut", rom0, align[8,low(-4)]
MapLut::
for V, 4
	db bank(Map{x:V})
endr