; le main file for this
; 
;        /"""/  /"""//"""""""""//"""/      /"""/
;       /   /  /   //   ______//   /      /   /
;      /   /  /   //   /      /   /      /   /
;     /    """   //    """""//   /      /   /
;    /   ___    //   ______//   /      /   /
;   /   /  /   //   /      /   /      /   /
;  /   /  /   //    """""//    """""//    """""/
; /___/  /___//_________//_________//_________/
; honestly i just dont know how to name this

; wanna help? ctrl+f for "todo:"

include "hardware.inc"
include "macros.inc"
include "defines.inc"

section "icrash", rom0[$38]
iCrash:
	ld b, b
	jr @

section "ivblank", rom0[$40]
iVBlank: ; push and jump to the real handler
	push af
	push bc
	push de
	push hl
	jp VBlank

section "vblank", rom0
VBlank: ; actual handler todo: handle text
	; check pending tasks
		ldh a, [hVBlank]
		and a
		jr z, .done
	; display text
		; check for the text task
			and VBLANK_TEXT
			jr z, .skipText
		; if so, prep to copy
			; first stupid tilemap tho
			ld a, low(vMapText>>4)
			ld b, 16
			ld hl, $9a00
			.loop
			ld [hl+], a
			inc a
			dec b
			jr nz, .loop
			; now copy
			ld a, [wVBlankText.bank]
			rom_bank 0
			ld a, [wVBlankText.addr]
			ld h, a
			xor a
			ld l, a
			ld bc, 256
			ld de, vMapText
			call Safe1bppCpy
		; remove task
			ldh a, [hVBlank]
			and ~VBLANK_TEXT
			ldh [hVBlank], a
	.skipText
	.done ; pop and return
		rom_bank
		pop hl
		pop de
		pop bc
		pop af
		reti

section "wvblank", wram0
wVBlankText:
	.addr    ds 1 ; high(text)
	.bank    ds 1 ; bank(text)
	.counter ds 1 ; counts displayed tiles

for V, 4
section "int{x:V}" , rom0[$48+(V*8)]
iInt{x:V}:
	rst iCrash
endr

section "header", rom0[$100]
	di
	jp ConsoleCheck
	ds $150-@, $00

section "title", rom0
Title::
	; load splash screen
		rom_bank xSplash2bpp
		; load tileset
			ld hl, xSplash2bpp
			ld de, _VRAM+$1000
			ld bc, xSplash2bpp.end - xSplash2bpp
			call SafeCpy
		; load map
			ld hl, xSplashTilemap
			ld de, _SCRN0
			ld bc, xSplashTilemap.end - xSplashTilemap
			call SafeCpy
.loop
	halt
	; poll
		call Joy
	; go to next screen once start is hit
		ld a, [hPad1]
		ld b, a
		ldh a, [hPad1.diff]
		and b
		and PADF_START
	jr z, .loop
	; clear map
		xor a
		ld hl, _SCRN0
		ld bc, _SCRN1 - _SCRN0
		call SafeSet
	jp Main

section "main", rom0
Main::
	; set player position
	ld a, bank(wxActor)
	ldh [rSMBK], a
	ld a, START_Y
	ld [wxActor.y], a
	if START_X != START_Y
		ld a, START_X
	endc
	ld [wxActor.x], a
	; load tileset
	rom_bank xTileset2bpp
	ld hl, xTileset2bpp
	ld de, vTileset
	ld bc, vTileset.end - vTileset
	call SafeCpy
	; load player
	ld hl, xPlayer2bpp
	ld de, _VRAM
	ld bc, xPlayer2bpp.end - xPlayer2bpp
	call SafeCpy
	; load the map
	call LoadMap
.loop
	halt
	; DMA shadowOAM
		ld a, high(wSOAM)
		call hDMA
	; poll input
		call Joy
	; move player
		call MovePlayer
	; fill shadowOAM
		call Display
	jr .loop

section "objects", rom0
Display: ; todo: replace this nonsense
	ld a, bank(wxActor)
	ldh [rSMBK], a
	ld a, [wxActor.y]
	res 4, a
	add 2 ; offset
	add a
	add a
	add a
	ld [wSOAM+0], a
	ld a, [wxActor.x]
	res 4, a
	inc a ; offset
	add a
	add a
	add a
	ld [wSOAM+1], a
	ret

section "player", rom0
MovePlayer: ; this is a black box im telling you
	; check if player wants to move
	ld a, [hPad1]
	ld b, a
	ldh a, [hPad1.diff]
	and b
	and PADF_UP | PADF_DOWN | PADF_LEFT | PADF_RIGHT
	ret z
	; if so, move
		ld b, a
		; todo: wrap this into a 
		; vertically
			ld a, [wxActor.x]
			ld l, a
			ld a, [wxActor.y]
			; down
			sla b
			adc 0
			; up
			sla b
			sbc 0
			ld h, a
			ld c, a
			; check if colliding
			call CollideMap
			and TILE_SOLID
			; discard if so
			jr nz, .skipV
			ld a, c
			ld [wxActor.y], a
			.skipV
		; horizontally
			ld a, [wxActor.y]
			ld h, a
			ld a, l
			; left
			sla b
			sbc 0
			; right
			sla b
			adc 0
			; check if colliding
			ld l, a
			call CollideMap
			and TILE_SOLID
			; discard if so
			jr nz, .skipH
			ld a, l
			ld [wxActor.x], a
			.skipH
		ld c, $f0
	; check if hi(plrX) != hi(CamX)
		ld a, [wxActor.x]
		ld b, a
		ldh a, [hCamera.x]
		xor b
		and c
		jr nz, .load
	; check if hi(plrY) != hi(CamY)
		ld a, [wxActor.y]
		ld b, a
		ldh a, [hCamera.y]
		xor b
		and c
	.load ; if either !=, reload the map
		jp nz, LoadMap ; tail call???
	ret

section "fetchmaptile", rom0 ; name possibly misleading?
FetchMapTile:: ; h - Y, l - X, rROMB = bank, hl = tile, clobbers de
	; since hl is practically already pointing to the
	; tile we only need to actually fetch the bank
	; fetch and switch to bank
	ld a, h
	rlca
	rlca
	or %11111100
		assert low(MapLut) == %11111100
	ld e, a
	ld d, high(MapLut)
	ld a, [de]
	rom_bank 0
	; adjust h
	res 7, h
	set 6, h
		assert high(xMap1)  == (%0<<7) | (%1<<6)
	ret

section "loadmap", rom0
LoadMap::
	ld a, bank(wxActor)
	ldh [rSMBK], a
	; fetch the screen bank & pointer, update camera
		ld a, [wxActor.y]
		and $f0
		ldh [hCamera.y], a
		ld h, a
		ld a, [wxActor.x]
		and $f0
		ldh [hCamera.x], a
		ld l, a
		call FetchMapTile
	; load the room into VRAM
		; load c and de
		ld c, 16 ; couldnt come up with a constant for this
		ld de, _SCRN0
		.column ; copy a column of rows
			ld b, 16/2 ; or this
			push hl ; faster to add 256 than 16 then 240
			.row ; copy a row
				.wait ; wait for safe access
					ldh a, [rSTAT]
					and STATF_BUSY
					jr nz, .wait
				rept 2 ; copy two bytes
					ld a, [hl+]
					ld [de], a
					inc e
					endr
				dec b
				jr nz, .row
			; adjust for the next row
				; hl
					pop hl
					inc h
				; de
					ld a, e
					add 15
					ld e, a
					inc de
				; then decrement counter
					dec c
					jr nz, .column
	; set the text renderer to display the rooms flavor text
		; fetch position
			ldh a, [hCamera.x]
			ld b, a
			ldh a, [hCamera.y]
			swap b
			or a, b
		; get bank and address
			; i wanted to wrap this in a macro but it wouldnt work
			; bank
			ld h, a
			rlca
			rlca
			and %00000011
				assert low(FlavorLut) == %00000000
			ld e, a
			ld d, high(FlavorLut)
			ld a, [de]
			; addr
			res 7, h
			set 6, h
				assert high(xFlavor1)  == (%0<<7) | (%1<<6)
		; set handler
			di
			ld [wVBlankText.bank], a
			ld a, h
			ld [wVBlankText.addr], a
			xor a
			ld [wVBlankText.counter], a
			ldh a, [hVBlank]
			or VBLANK_TEXT
			ldh [hVBlank], a
			ei ; (shut up shut up shut up shut)
	; done
	ret

section "hram", hram
hCamera::
	.y ds 1 ; y position of camera
	.x ds 1 ; x position of camera
hShadowROMB:: ds 1 ; shadow of the bank register
hVBlank:: ds 1 ; ; "task list" for VBlank handler

section "collidemap", rom0
CollideMap:: ; h - Y, l - X, h = %01000000 | (h & %00111111)
	call FetchMapTile
.noSwitch:: ; preserves hl
	ld a, [hl]
	push hl
	ld h, high(TileProperties)
	ld l, a
	ld a, [hl]
	pop hl
	; done
	ret

section "actors", wramx, align[8]
wxActor::
	.type ds 1
	.y    ds 1
	.x    ds 1
.next ds 256*(MAX_ACTORS-1)

section "tileset", romx
xTileset2bpp:
	load "vtileset", vram[$9000]
	vTileset:
	incbin "tileset.2bpp"
	.end
	endl
xPlayer2bpp:
	incbin "player.2bpp"
	.end

section "maptext", vram[$8c00]
vMapText:
	ds $10 * 16 * 2
	.end

section "menutext", vram[$8e00]
vMenuText:
	ds $10 * 16 * 2
	.end

section "splash", romx
xSplash2bpp:
	incbin "splash.2bpp"
	.end
xSplashTilemap:
	incbin "splash.tilemap"
	.end

for V, 4
section "map{x:V}", romx
xMap{x:V}::
	incbin "map.bin", V*16384, 16384
endr

for V, 4
section "flavor{x:V}", romx
xFlavor{x:V}::
	for V2, 4
		for V3, 16
			incbin "flavor.bin", (V*16384)+(V2*4096)+(V3*128)+(000*16), 128
			;print (V*128)+(V2*32)+(V3*1)+(0*16), " "
			incbin "flavor.bin", (V*16384)+(V2*4096)+(V3*128)+(128*16), 128
			;print (V*128)+(V2*32)+(V3*1)+(1*16), " "
		endr
	endr
endr

section "maplut", rom0, align[8,low(-4)]
MapLut::
for V, 4
	db bank(xMap{x:V})
endr

section "flavorlut", rom0, align[8]
FlavorLut::
for V, 4
	db bank(xFlavor{x:V})
endr